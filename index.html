<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Urban Transit Simulator</title>
    
    <!-- LeafletJS e plugins -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Leaflet Routing Machine para rotas realistas -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

    <!-- TailwindCSS para o estilo -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: 'Inter', sans-serif; }
        #map { height: 100%; width: 100%; cursor: crosshair; }
        .leaflet-popup-content-wrapper, .leaflet-popup-tip {
            background: rgba(31, 41, 55, 0.8); color: #fff; backdrop-filter: blur(5px);
            box-shadow: 0 3px 14px rgba(0,0,0,0.4); border-radius: 8px; border: 1px solid rgba(75, 85, 99, 0.7);
        }
        .leaflet-popup-content { margin: 12px; }
        .leaflet-popup-tip { background: rgba(31, 41, 55, 0.8); }
        .leaflet-container a.leaflet-popup-close-button { color: #fff; }
        .leaflet-routing-container { display: none; }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div id="game-container" class="flex h-screen w-screen">
        
        <!-- Painel de Controle -->
        <div id="ui-panel" class="w-1/4 max-w-sm h-full bg-gray-800 p-4 shadow-2xl z-10 overflow-y-auto flex flex-col space-y-4">
            <h1 class="text-2xl font-bold text-cyan-400 mb-2 border-b border-gray-700 pb-2">Urban Transit Sim</h1>
            
            <div class="grid grid-cols-2 gap-4">
                <div class="bg-gray-700 p-3 rounded-lg text-center">
                    <p class="text-sm text-gray-400">Dinheiro</p>
                    <p id="money-display" class="text-xl font-bold text-green-400">R$ 10000</p>
                </div>
                <div class="bg-gray-700 p-3 rounded-lg text-center">
                    <p class="text-sm text-gray-400">Passageiros</p>
                    <p id="passengers-display" class="text-xl font-bold text-yellow-400">0</p>
                </div>
            </div>

            <div class="bg-gray-900/50 p-3 rounded-lg">
                <h2 class="text-lg font-semibold mb-2 text-cyan-300">Mudar de Cidade</h2>
                <div class="flex space-x-2 items-center">
                    <input type="text" id="city-input" placeholder="Ex: Groaíras" class="flex-grow bg-gray-700 border border-gray-600 rounded-lg py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-cyan-500">
                    <button id="change-city-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold p-2 rounded-lg transition-all duration-200">
                        <svg id="search-icon" class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 3.5a5.5 5.5 0 100 11 5.5 5.5 0 000-11zM2 9a7 7 0 1112.452 4.391l3.328 3.329a.75.75 0 11-1.06 1.06l-3.329-3.328A7 7 0 012 9z" clip-rule="evenodd" /></svg>
                        <svg id="loading-icon" class="animate-spin h-5 w-5 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                    </button>
                </div>
            </div>

            <div class="bg-gray-900/50 p-3 rounded-lg">
                <h2 class="text-lg font-semibold mb-2 text-cyan-300">Gerenciar Ônibus</h2>
                <div class="space-y-2">
                    <button id="add-stop-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200">1. Adicionar Parada (R$100)</button>
                    <button id="create-route-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200" disabled>2. Criar Rota</button>
                    <div class="flex items-center space-x-2">
                        <select id="route-select" class="w-full bg-gray-700 border border-gray-600 rounded-lg py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-cyan-500"><option value="">Selecione uma rota</option></select>
                        <button id="delete-route-btn" class="bg-red-600 hover:bg-red-700 p-2 rounded-lg" disabled><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                    </div>
                    <button id="buy-bus-btn" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200" disabled>Comprar Ônibus (R$1000)</button>
                </div>
            </div>

            <div class="bg-gray-900/50 p-3 rounded-lg">
                 <h2 class="text-lg font-semibold mb-2 text-cyan-300">Gerenciar Táxis</h2>
                 <button id="buy-taxi-btn" class="w-full bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold py-2 px-4 rounded-lg transition-all duration-200">Comprar Táxi (R$2500)</button>
            </div>

            <div class="flex-grow bg-gray-900 rounded-lg p-3 min-h-[100px]">
                <h3 class="font-semibold text-gray-400 mb-2">Log de Eventos</h3>
                <div id="message-log" class="text-sm text-gray-300 space-y-1 overflow-y-auto h-full"><p>Bem-vindo! Construa paradas ou compre táxis.</p></div>
            </div>
        </div>

        <div id="map" class="flex-grow h-full"></div>
    </div>

    <script type="module">
        const INITIAL_MONEY = 10000, STOP_COST = 100, BUS_COST = 1000, TAXI_COST = 2500;
        const BUS_TICKET_PRICE = 5, TAXI_FARE_PER_KM = 3, BUILDING_COUNT = 50, PASSENGER_SPAWN_RATE = 3000;
        const OPERATING_RADIUS = 7000; // 7km

        let money, passengersServed, routes, buses, taxis, buildings, passengers, tempStops, map, operatingAreaCircle, nextRouteId;
        let isPlacingStops = false;
        const buildingMarkers = L.layerGroup();

        const moneyDisplay = document.getElementById('money-display'), passengersDisplay = document.getElementById('passengers-display');
        const addStopBtn = document.getElementById('add-stop-btn'), createRouteBtn = document.getElementById('create-route-btn');
        const buyBusBtn = document.getElementById('buy-bus-btn'), buyTaxiBtn = document.getElementById('buy-taxi-btn');
        const routeSelect = document.getElementById('route-select'), messageLog = document.getElementById('message-log');
        const deleteRouteBtn = document.getElementById('delete-route-btn');
        const cityInput = document.getElementById('city-input'), changeCityBtn = document.getElementById('change-city-btn');
        const searchIcon = document.getElementById('search-icon'), loadingIcon = document.getElementById('loading-icon');

        const houseIcon = L.icon({ iconUrl: 'https://img.icons8.com/plasticine/100/000000/cottage.png', iconSize: [35, 35] });
        const commercialIcon = L.icon({ iconUrl: 'https://img.icons8.com/plasticine/100/000000/company.png', iconSize: [40, 40] });
        const busStopIcon = L.icon({ iconUrl: 'https://img.icons8.com/fluency/48/bus-stop.png', iconSize: [30, 30] });
        const busIcon = L.icon({ iconUrl: 'https://img.icons8.com/emoji/48/bus-emoji.png', iconSize: [32, 32] });
        const taxiIcon = L.icon({ iconUrl: 'https://img.icons8.com/officel/48/taxi.png', iconSize: [32, 32] });

        function init() {
            map = L.map('map', { zoomControl: false }).setView([-23.5505, -46.6333], 13);
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd', maxZoom: 20
            }).addTo(map);
            L.control.zoom({ position: 'bottomright' }).addTo(map);
            
            buildingMarkers.addTo(map);
            resetGame();
            addEventListeners();
            
            setInterval(gameLoop, 1000 / 30);
            setInterval(spawnPassenger, PASSENGER_SPAWN_RATE);
        }

        function addEventListeners() {
            addStopBtn.addEventListener('click', togglePlacingStops);
            createRouteBtn.addEventListener('click', createRoute);
            buyBusBtn.addEventListener('click', buyBus);
            buyTaxiBtn.addEventListener('click', buyTaxi);
            changeCityBtn.addEventListener('click', changeCity);
            deleteRouteBtn.addEventListener('click', deleteRoute);
            routeSelect.addEventListener('change', updateUI);
            map.on('click', onMapClick);
        }

        function resetGame(center = map.getCenter(), zoom = map.getZoom()) {
            money = INITIAL_MONEY;
            passengersServed = 0;
            routes = []; buses = []; taxis = []; buildings = []; passengers = []; tempStops = [];
            nextRouteId = 0;
            
            map.eachLayer(layer => { if (!!layer.toGeoJSON) map.removeLayer(layer); });
            buildingMarkers.clearLayers();
            if(operatingAreaCircle) map.removeLayer(operatingAreaCircle);
            
            map.setView(center, zoom);
            operatingAreaCircle = L.circle(center, { radius: OPERATING_RADIUS, color: '#06b6d4', weight: 2, dashArray: '10, 5', fillOpacity: 0.05 }).addTo(map);
            spawnBuildings();
            updateUI();
            logMessage("Simulação iniciada. Boa sorte!", "success");
        }

        function spawnBuildings() {
            const center = operatingAreaCircle.getLatLng();
            const radius = operatingAreaCircle.getRadius();
            
            for (let i = 0; i < BUILDING_COUNT; i++) {
                // Gera um ponto aleatório dentro do círculo
                const r = radius * Math.sqrt(Math.random());
                const theta = Math.random() * 2 * Math.PI;
                const lat = center.lat + (r / 111320) * Math.cos(theta);
                const lng = center.lng + (r / (111320 * Math.cos(center.lat * Math.PI/180))) * Math.sin(theta);

                // Garante uma mistura de prédios
                const type = i < BUILDING_COUNT / 2 ? 'residential' : 'commercial';
                const icon = type === 'residential' ? houseIcon : commercialIcon;
                const marker = L.marker([lat, lng], { icon });
                marker.bindPopup(`<b>${type === 'residential' ? 'Área Residencial' : 'Área Comercial'}</b>`);
                buildingMarkers.addLayer(marker);
                buildings.push({ lat, lng, type, marker });
            }
        }
        
        async function changeCity() {
            const cityName = cityInput.value;
            if (!cityName) return;
            searchIcon.classList.add('hidden'); loadingIcon.classList.remove('hidden');
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(cityName)}&format=json&limit=1`);
                const data = await response.json();
                if (data && data.length > 0) {
                    const { lat, lon } = data[0];
                    logMessage(`${cityName} encontrada! Reiniciando simulação.`, "success");
                    resetGame([lat, lon], 14); // Aumenta o zoom para cidades menores
                } else {
                    logMessage(`Cidade "${cityName}" não encontrada.`, "error");
                }
            } catch (error) {
                logMessage("Erro ao buscar cidade.", "error");
            } finally {
                searchIcon.classList.remove('hidden'); loadingIcon.classList.add('hidden');
            }
        }

        function gameLoop() {
            updateBuses();
            updateTaxis();
            updatePassengersUI();
        }

        function updateUI() {
            moneyDisplay.textContent = `R$ ${money.toFixed(0)}`;
            passengersDisplay.textContent = passengersServed;
            const selectedValue = routeSelect.value;
            routeSelect.innerHTML = '<option value="">Selecione uma rota</option>';
            routes.forEach(route => {
                const option = document.createElement('option');
                option.value = route.id;
                option.textContent = `Rota ${route.id + 1} (${route.stops.length} paradas)`;
                routeSelect.appendChild(option);
            });
            routeSelect.value = selectedValue;
            buyBusBtn.disabled = routeSelect.value === "" || money < BUS_COST;
            buyTaxiBtn.disabled = money < TAXI_COST;
            deleteRouteBtn.disabled = routeSelect.value === "";
            createRouteBtn.disabled = tempStops.length < 2;
        }

        function logMessage(msg, type = 'info') {
            const p = document.createElement('p');
            p.textContent = msg;
            if (type === 'error') p.className = 'text-red-400';
            if (type === 'success') p.className = 'text-green-400';
            messageLog.prepend(p);
            if (messageLog.children.length > 10) messageLog.lastChild.remove();
        }
        
        function togglePlacingStops() {
            isPlacingStops = !isPlacingStops;
            addStopBtn.classList.toggle('ring-2'); addStopBtn.classList.toggle('ring-cyan-400');
            addStopBtn.textContent = isPlacingStops ? "Parar de Adicionar Paradas" : "1. Adicionar Parada (R$100)";
        }

        function onMapClick(e) {
            if (!isPlacingStops || money < STOP_COST) return;
            money -= STOP_COST;
            const stopMarker = L.marker(e.latlng, { icon: busStopIcon }).addTo(map);
            stopMarker.bindPopup(`<b>Parada Temporária ${tempStops.length + 1}</b>`);
            tempStops.push({ lat: e.latlng.lat, lng: e.latlng.lng, marker: stopMarker, passengers: [] });
            logMessage(`Parada ${tempStops.length} adicionada.`, "success");
            updateUI();
        }

        function createRoute() {
            if (tempStops.length < 2) return;
            const routeId = nextRouteId++;
            const routeColor = `#${Math.floor(Math.random()*16777215).toString(16)}`;
            const routeLine = L.polyline(tempStops.map(s => [s.lat, s.lng]), { color: routeColor, weight: 4, opacity: 0.7 }).addTo(map);
            routes.push({ id: routeId, stops: tempStops, line: routeLine, color: routeColor });
            tempStops.forEach((stop, index) => {
                stop.marker.bindPopup(`<b>Rota ${routeId + 1} - Parada ${index + 1}</b><br>Passageiros: <span id="stop-${routeId}-${index}">0</span>`);
            });
            tempStops = [];
            if (isPlacingStops) togglePlacingStops();
            logMessage(`Rota ${routeId + 1} criada!`, "success");
            updateUI(); // Atualiza a UI primeiro
            routeSelect.value = routeId; // Depois seleciona o valor
            updateUI(); // Atualiza de novo para habilitar o botão de compra
        }

        function deleteRoute() {
            const routeId = parseInt(routeSelect.value);
            if (isNaN(routeId)) return;

            const routeToRemove = routes.find(r => r.id === routeId);
            if (!routeToRemove) return;

            // Remove ônibus da rota
            buses = buses.filter(bus => {
                if (bus.routeId === routeId) {
                    map.removeLayer(bus.marker);
                    return false;
                }
                return true;
            });

            map.removeLayer(routeToRemove.line);
            routeToRemove.stops.forEach(stop => map.removeLayer(stop.marker));
            routes = routes.filter(r => r.id !== routeId);
            
            logMessage(`Rota ${routeId + 1} foi excluída.`, 'info');
            updateUI();
        }
        
        function buyBus() {
            const routeId = parseInt(routeSelect.value);
            if (isNaN(routeId) || money < BUS_COST) return;
            
            const route = routes.find(r => r.id === routeId);
            if (!route) return;

            money -= BUS_COST;
            const startStop = route.stops[0];
            const busMarker = L.marker([startStop.lat, startStop.lng], { icon: busIcon, zIndexOffset: 1000 }).addTo(map);
            busMarker.bindPopup(`<b>Ônibus Rota ${route.id + 1}</b><br>Passageiros: 0/10`);
            const newBus = { id: buses.length, routeId: route.id, marker: busMarker, currentStopIndex: 0, path: [], progress: 0, passengers: [], capacity: 10 };
            buses.push(newBus);
            getRoutePath(route.stops[0], route.stops[1], path => { newBus.path = path; });
            logMessage(`Ônibus comprado para a Rota ${route.id + 1}.`, "success");
            updateUI();
        }

        function buyTaxi() {
            if (money < TAXI_COST) return;
            money -= TAXI_COST;
            const startPos = buildings[Math.floor(Math.random() * buildings.length)];
            const taxiMarker = L.marker([startPos.lat, startPos.lng], { icon: taxiIcon, zIndexOffset: 1000 }).addTo(map);
            taxiMarker.bindPopup(`<b>Táxi ${taxis.length + 1}</b><br>Status: Ocioso`);
            taxis.push({ id: taxis.length, marker: taxiMarker, status: 'idle', passenger: null, path: [], progress: 0 });
            logMessage("Táxi comprado e pronto para trabalhar!", "success");
            updateUI();
        }

        function spawnPassenger() {
            if (buildings.length < 2) return;
            const origin = buildings[Math.floor(Math.random() * buildings.length)];
            const destination = buildings[Math.floor(Math.random() * buildings.length)];
            if (origin === destination) return;

            const passenger = { id: Date.now(), origin, destination, status: 'waiting' };
            const nearestStartStopInfo = findNearestStop(passenger.origin);
            if (nearestStartStopInfo && nearestStartStopInfo.distance < 1000) {
                nearestStartStopInfo.stop.passengers.push(passenger);
            } else {
                passengers.push(passenger);
            }
        }

        function findNearestStop(position) {
            let closest = null, minDistance = Infinity;
            routes.forEach(route => {
                route.stops.forEach((stop) => {
                    const distance = L.latLng(position).distanceTo(L.latLng(stop));
                    if (distance < minDistance) {
                        minDistance = distance;
                        closest = { route, stop, distance };
                    }
                });
            });
            return closest;
        }
        
        function updatePassengersUI() {
            routes.forEach(route => {
                route.stops.forEach((stop, stopIndex) => {
                    const span = document.getElementById(`stop-${route.id}-${stopIndex}`);
                    if(span) span.textContent = stop.passengers.length;
                });
            });
        }

        function getRoutePath(start, end, callback) {
            const router = L.Routing.control({
                waypoints: [ L.latLng(start.lat, start.lng), L.latLng(end.lat, end.lng) ],
                createMarker: () => null, routeWhileDragging: false, addWaypoints: false,
                router: L.Routing.osrmv1({ serviceUrl: 'https://router.project-osrm.org/route/v1' })
            });
            router.on('routesfound', e => callback(e.routes[0].coordinates)).addTo(map);
        }

        function updateBuses() {
            buses.forEach(bus => {
                const route = routes.find(r => r.id === bus.routeId);
                if (!route || !bus.path || bus.path.length === 0) return;

                bus.progress += 0.6; // Velocidade do ônibus
                const pathIndex = Math.floor(bus.progress);

                if (pathIndex >= bus.path.length) {
                    bus.currentStopIndex = (bus.currentStopIndex + 1) % route.stops.length;
                    handleBusAtStop(bus);
                    const nextStopIndex = (bus.currentStopIndex + 1) % route.stops.length;
                    const currentStop = route.stops[bus.currentStopIndex];
                    const nextStop = route.stops[nextStopIndex];
                    getRoutePath(currentStop, nextStop, path => {
                        bus.path = path;
                        bus.progress = 0;
                    });
                    return;
                }
                bus.marker.setLatLng(bus.path[pathIndex]);
            });
        }
        
        function updateTaxis() {
            const idleTaxis = taxis.filter(t => t.status === 'idle');
            const waitingForTaxi = passengers.filter(p => p.status === 'waiting');

            if (idleTaxis.length > 0 && waitingForTaxi.length > 0) {
                const taxi = idleTaxis[0];
                const passenger = waitingForTaxi.shift();
                taxi.status = 'pickup';
                taxi.passenger = passenger;
                getRoutePath(taxi.marker.getLatLng(), passenger.origin, path => {
                    taxi.path = path; taxi.progress = 0;
                });
                taxi.marker.setPopupContent(`<b>Táxi ${taxi.id + 1}</b><br>A caminho do passageiro`);
            }

            taxis.forEach(taxi => {
                if (taxi.status === 'idle' || !taxi.path || taxi.path.length === 0) return;
                
                taxi.progress += 1.0; // Velocidade do táxi
                const pathIndex = Math.floor(taxi.progress);

                if (pathIndex >= taxi.path.length) {
                    if (taxi.status === 'pickup') {
                        taxi.status = 'dropoff';
                        taxi.marker.setLatLng(taxi.passenger.origin);
                        getRoutePath(taxi.passenger.origin, taxi.passenger.destination, path => {
                            taxi.path = path; taxi.progress = 0;
                        });
                        taxi.marker.setPopupContent(`<b>Táxi ${taxi.id + 1}</b><br>Levando ao destino`);
                    } else if (taxi.status === 'dropoff') {
                        const distance = L.latLng(taxi.passenger.origin).distanceTo(L.latLng(taxi.passenger.destination)) / 1000;
                        const fare = Math.max(5, distance * TAXI_FARE_PER_KM);
                        money += fare; passengersServed++;
                        logMessage(`Táxi deixou passageiro. +R$${fare.toFixed(2)}`, 'success');
                        
                        taxi.status = 'idle'; taxi.passenger = null; taxi.path = [];
                        taxi.marker.setPopupContent(`<b>Táxi ${taxi.id + 1}</b><br>Status: Ocioso`);
                        updateUI();
                    }
                } else {
                    taxi.marker.setLatLng(taxi.path[pathIndex]);
                }
            });
        }

        function handleBusAtStop(bus) {
            const route = routes.find(r => r.id === bus.routeId);
            if (!route) return;
            const stop = route.stops[bus.currentStopIndex];
            
            const passengersToDrop = [];
            bus.passengers.forEach(p => {
                let bestStopForDest = null, minDistance = Infinity;
                route.stops.forEach(s => {
                    const d = L.latLng(p.destination).distanceTo(L.latLng(s));
                    if (d < minDistance) { minDistance = d; bestStopForDest = s; }
                });
                if (bestStopForDest === stop) passengersToDrop.push(p);
            });
            if (passengersToDrop.length > 0) {
                bus.passengers = bus.passengers.filter(p => !passengersToDrop.some(dp => dp.id === p.id));
                money += passengersToDrop.length * BUS_TICKET_PRICE;
                passengersServed += passengersToDrop.length;
                logMessage(`${passengersToDrop.length} passageiros desembarcaram. +R$${passengersToDrop.length * BUS_TICKET_PRICE}`, 'success');
            }

            const space = bus.capacity - bus.passengers.length;
            const boarded = stop.passengers.splice(0, space);
            if (boarded.length > 0) {
                bus.passengers.push(...boarded);
                logMessage(`${boarded.length} passageiros embarcaram.`, 'info');
            }
            
            bus.marker.setPopupContent(`<b>Ônibus Rota ${bus.routeId + 1}</b><br>Passageiros: ${bus.passengers.length}/${bus.capacity}`);
            updateUI();
        }

        init();
    </script>
</body>
</html>

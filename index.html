<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Urban Transit Simulator</title>
    
    <!-- LeafletJS e plugins -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Leaflet Routing Machine para rotas realistas -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

    <!-- TailwindCSS para o estilo -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: 'Inter', sans-serif; }
        #map { height: 100%; width: 100%; cursor: crosshair; }
        .leaflet-popup-content-wrapper, .leaflet-popup-tip {
            background: rgba(31, 41, 55, 0.8); color: #fff; backdrop-filter: blur(5px);
            box-shadow: 0 3px 14px rgba(0,0,0,0.4); border-radius: 8px; border: 1px solid rgba(75, 85, 99, 0.7);
        }
        .leaflet-popup-content { margin: 12px; }
        .leaflet-popup-tip { background: rgba(31, 41, 55, 0.8); }
        .leaflet-container a.leaflet-popup-close-button { color: #fff; }
        .leaflet-routing-container { display: none; }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div id="game-container" class="flex h-screen w-screen">
        
        <!-- Painel de Controle -->
        <div id="ui-panel" class="w-1/4 max-w-sm h-full bg-gray-800 p-4 shadow-2xl z-10 overflow-y-auto flex flex-col space-y-4">
            <h1 class="text-2xl font-bold text-cyan-400 mb-2 border-b border-gray-700 pb-2">Urban Transit Sim</h1>
            
            <div class="grid grid-cols-2 gap-4">
                <div class="bg-gray-700 p-3 rounded-lg text-center">
                    <p class="text-sm text-gray-400">Dinheiro</p>
                    <p id="money-display" class="text-xl font-bold text-green-400">R$ 10000</p>
                </div>
                <div class="bg-gray-700 p-3 rounded-lg text-center">
                    <p class="text-sm text-gray-400">Passageiros</p>
                    <p id="passengers-display" class="text-xl font-bold text-yellow-400">0</p>
                </div>
            </div>

            <div class="bg-gray-900/50 p-3 rounded-lg">
                <h2 class="text-lg font-semibold mb-2 text-cyan-300">Mudar de Cidade</h2>
                <div class="flex space-x-2 items-center">
                    <input type="text" id="city-input" placeholder="Ex: Groaíras" class="flex-grow bg-gray-700 border border-gray-600 rounded-lg py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-cyan-500">
                    <button id="change-city-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold p-2 rounded-lg transition-all duration-200">
                        <svg id="search-icon" class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 3.5a5.5 5.5 0 100 11 5.5 5.5 0 000-11zM2 9a7 7 0 1112.452 4.391l3.328 3.329a.75.75 0 11-1.06 1.06l-3.329-3.328A7 7 0 012 9z" clip-rule="evenodd" /></svg>
                        <svg id="loading-icon" class="animate-spin h-5 w-5 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                    </button>
                </div>
            </div>

            <div class="bg-gray-900/50 p-3 rounded-lg">
                <h2 class="text-lg font-semibold mb-2 text-cyan-300">Gerenciar Ônibus</h2>
                <div class="space-y-2">
                    <button id="add-stop-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200">1. Adicionar Parada (R$100)</button>
                    <button id="create-route-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200" disabled>2. Criar Rota</button>
                    <div class="flex items-center space-x-2">
                        <select id="route-select" class="w-full bg-gray-700 border border-gray-600 rounded-lg py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-cyan-500"><option value="">Selecione uma rota</option></select>
                        <button id="delete-route-btn" class="bg-red-600 hover:bg-red-700 p-2 rounded-lg" disabled><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                    </div>
                    <button id="buy-bus-btn" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200" disabled>Comprar Ônibus (R$1000)</button>
                </div>
            </div>

            <div class="bg-gray-900/50 p-3 rounded-lg">
                 <h2 class="text-lg font-semibold mb-2 text-cyan-300">Gerenciar Táxis</h2>
                 <button id="buy-taxi-btn" class="w-full bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold py-2 px-4 rounded-lg transition-all duration-200">Comprar Táxi (R$2500)</button>
            </div>

            <div class="flex-grow bg-gray-900 rounded-lg p-3 min-h-[100px]">
                <h3 class="font-semibold text-gray-400 mb-2">Log de Eventos</h3>
                <div id="message-log" class="text-sm text-gray-300 space-y-1 overflow-y-auto h-full"><p>Bem-vindo! Construa paradas ou compre táxis.</p></div>
            </div>
        </div>

        <div id="map" class="flex-grow h-full"></div>
    </div>

    <script type="module">
        const INITIAL_MONEY = 10000, STOP_COST = 100, BUS_COST = 1000, TAXI_COST = 2500;
        const BUS_TICKET_PRICE = 5, TAXI_FARE_PER_KM = 3, PASSENGER_SPAWN_RATE = 5000;
        const FRAME_RATE = 30; // 30 frames por segundo

        let money, passengersServed, routes, buses, taxis, buildings, passengers, tempStops, map, nextRouteId;
        let isPlacingStops = false;
        let lastFrameTime = Date.now();
        const buildingMarkers = L.layerGroup();

        const moneyDisplay = document.getElementById('money-display'), passengersDisplay = document.getElementById('passengers-display');
        const addStopBtn = document.getElementById('add-stop-btn'), createRouteBtn = document.getElementById('create-route-btn');
        const buyBusBtn = document.getElementById('buy-bus-btn'), buyTaxiBtn = document.getElementById('buy-taxi-btn');
        const routeSelect = document.getElementById('route-select'), messageLog = document.getElementById('message-log');
        const deleteRouteBtn = document.getElementById('delete-route-btn');
        const cityInput = document.getElementById('city-input'), changeCityBtn = document.getElementById('change-city-btn');
        const searchIcon = document.getElementById('search-icon'), loadingIcon = document.getElementById('loading-icon');

        const houseIcon = L.icon({ iconUrl: 'https://img.icons8.com/plasticine/100/000000/cottage.png', iconSize: [35, 35] });
        const commercialIcon = L.icon({ iconUrl: 'https://img.icons8.com/plasticine/100/000000/company.png', iconSize: [40, 40] });
        const busStopIcon = L.icon({ iconUrl: 'https://img.icons8.com/fluency/48/bus-stop.png', iconSize: [30, 30] });
        const busIcon = L.icon({ iconUrl: 'https://img.icons8.com/emoji/48/bus-emoji.png', iconSize: [32, 32] });
        const taxiIcon = L.icon({ iconUrl: 'https://img.icons8.com/officel/48/taxi.png', iconSize: [32, 32] });

        function init() {
            map = L.map('map', { zoomControl: false }).setView([-23.5505, -46.6333], 13);
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd', maxZoom: 20
            }).addTo(map);
            L.control.zoom({ position: 'bottomright' }).addTo(map);
            
            buildingMarkers.addTo(map);
            resetGame();
            addEventListeners();
            
            setInterval(gameLoop, 1000 / FRAME_RATE);
            setInterval(spawnPassenger, PASSENGER_SPAWN_RATE);
        }

        function addEventListeners() {
            addStopBtn.addEventListener('click', togglePlacingStops);
            createRouteBtn.addEventListener('click', createRoute);
            buyBusBtn.addEventListener('click', buyBus);
            buyTaxiBtn.addEventListener('click', buyTaxi);
            changeCityBtn.addEventListener('click', changeCity);
            deleteRouteBtn.addEventListener('click', deleteRoute);
            routeSelect.addEventListener('change', updateUI);
            map.on('click', onMapClick);
            map.on('moveend', fetchMapData); // Busca POIs quando o mapa para de mover
        }

        function resetGame(center = map.getCenter(), zoom = map.getZoom()) {
            money = INITIAL_MONEY;
            passengersServed = 0;
            routes = []; buses = []; taxis = []; buildings = []; passengers = []; tempStops = [];
            nextRouteId = 0;
            
            map.eachLayer(layer => { if (!!layer.toGeoJSON) map.removeLayer(layer); });
            buildingMarkers.clearLayers();
            
            map.setView(center, zoom);
            fetchMapData();
            updateUI();
            logMessage("Simulação iniciada. Boa sorte!", "success");
        }

        async function fetchMapData() {
            logMessage("Buscando locais de interesse na área...", "info");
            const bounds = map.getBounds();
            const bbox = `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`;
            const query = `
                [out:json][timeout:25];
                (
                  node["building"~"apartments|residential|house"](bbox);
                  way["building"~"apartments|residential|house"](bbox);
                  relation["building"~"apartments|residential|house"](bbox);
                  
                  node["building"~"commercial|office|retail|shop"](bbox);
                  way["building"~"commercial|office|retail|shop"](bbox);
                  relation["building"~"commercial|office|retail|shop"](bbox);
                );
                out center;
            `.replace(/\(bbox\)/g, `(${bbox})`).replace(/\s\s+/g, ' ');

            try {
                const response = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`);
                const data = await response.json();
                
                buildingMarkers.clearLayers();
                buildings = [];

                data.elements.forEach(el => {
                    const pos = el.type === 'node' ? { lat: el.lat, lon: el.lon } : { lat: el.center.lat, lon: el.center.lon };
                    const type = (el.tags.building === 'commercial' || el.tags.building === 'office' || el.tags.building === 'retail' || el.tags.building === 'shop') ? 'commercial' : 'residential';
                    const icon = type === 'commercial' ? commercialIcon : houseIcon;
                    const marker = L.marker([pos.lat, pos.lon], { icon });
                    marker.bindPopup(`<b>${el.tags.name || (type === 'commercial' ? 'Comércio' : 'Residência')}</b>`);
                    buildingMarkers.addLayer(marker);
                    buildings.push({ lat: pos.lat, lng: pos.lon, type, marker });
                });
                logMessage(`${buildings.length} locais encontrados.`, 'success');
            } catch (e) {
                logMessage("Erro ao buscar dados do mapa.", "error");
            }
        }
        
        async function changeCity() {
            const cityName = cityInput.value;
            if (!cityName) return;
            searchIcon.classList.add('hidden'); loadingIcon.classList.remove('hidden');
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(cityName)}&format=json&limit=1`);
                const data = await response.json();
                if (data && data.length > 0) {
                    const { lat, lon } = data[0];
                    logMessage(`${cityName} encontrada! Reiniciando simulação.`, "success");
                    resetGame([lat, lon], 14);
                } else {
                    logMessage(`Cidade "${cityName}" não encontrada.`, "error");
                }
            } catch (error) {
                logMessage("Erro ao buscar cidade.", "error");
            } finally {
                searchIcon.classList.remove('hidden'); loadingIcon.classList.add('hidden');
            }
        }

        function gameLoop() {
            const now = Date.now();
            const deltaTime = (now - lastFrameTime) / 1000.0; // Delta time em segundos
            lastFrameTime = now;

            updateVehicles(buses, deltaTime);
            updateVehicles(taxis, deltaTime);
            updatePassengersUI();
        }

        function updateUI() {
            moneyDisplay.textContent = `R$ ${money.toFixed(0)}`;
            passengersDisplay.textContent = passengersServed;
            const selectedValue = routeSelect.value;
            routeSelect.innerHTML = '<option value="">Selecione uma rota</option>';
            routes.forEach(route => {
                const option = document.createElement('option');
                option.value = route.id;
                option.textContent = `Rota ${route.id + 1} (${route.stops.length} paradas)`;
                routeSelect.appendChild(option);
            });
            if(selectedValue) routeSelect.value = selectedValue;
            buyBusBtn.disabled = routeSelect.value === "" || money < BUS_COST;
            buyTaxiBtn.disabled = money < TAXI_COST;
            deleteRouteBtn.disabled = routeSelect.value === "";
            createRouteBtn.disabled = tempStops.length < 2;
        }

        function logMessage(msg, type = 'info') {
            const p = document.createElement('p');
            p.textContent = msg;
            if (type === 'error') p.className = 'text-red-400';
            if (type === 'success') p.className = 'text-green-400';
            messageLog.prepend(p);
            if (messageLog.children.length > 10) messageLog.lastChild.remove();
        }
        
        function togglePlacingStops() {
            isPlacingStops = !isPlacingStops;
            addStopBtn.classList.toggle('ring-2'); addStopBtn.classList.toggle('ring-cyan-400');
            addStopBtn.textContent = isPlacingStops ? "Parar de Adicionar Paradas" : "1. Adicionar Parada (R$100)";
        }

        function onMapClick(e) {
            if (!isPlacingStops || money < STOP_COST) return;
            money -= STOP_COST;
            const stopMarker = L.marker(e.latlng, { icon: busStopIcon }).addTo(map);
            stopMarker.bindPopup(`<b>Parada Temporária ${tempStops.length + 1}</b>`);
            tempStops.push({ lat: e.latlng.lat, lng: e.latlng.lng, marker: stopMarker, passengers: [] });
            logMessage(`Parada ${tempStops.length} adicionada.`, "success");
            updateUI();
        }

        function createRoute() {
            if (tempStops.length < 2) return;
            const routeId = nextRouteId++;
            const routeColor = `#${Math.floor(Math.random()*16777215).toString(16)}`;
            const routeLine = L.polyline(tempStops.map(s => [s.lat, s.lng]), { color: routeColor, weight: 4, opacity: 0.7 }).addTo(map);
            routes.push({ id: routeId, stops: tempStops, line: routeLine, color: routeColor });
            tempStops.forEach((stop, index) => {
                stop.marker.bindPopup(`<b>Rota ${routeId + 1} - Parada ${index + 1}</b><br>Passageiros: <span id="stop-${routeId}-${index}">0</span>`);
            });
            tempStops = [];
            if (isPlacingStops) togglePlacingStops();
            logMessage(`Rota ${routeId + 1} criada!`, "success");
            updateUI(); 
            routeSelect.value = routeId;
            updateUI();
        }

        function deleteRoute() {
            const routeId = parseInt(routeSelect.value);
            if (isNaN(routeId)) return;
            const routeToRemove = routes.find(r => r.id === routeId);
            if (!routeToRemove) return;
            buses = buses.filter(bus => {
                if (bus.routeId === routeId) { map.removeLayer(bus.marker); return false; }
                return true;
            });
            map.removeLayer(routeToRemove.line);
            routeToRemove.stops.forEach(stop => map.removeLayer(stop.marker));
            routes = routes.filter(r => r.id !== routeId);
            logMessage(`Rota ${routeId + 1} foi excluída.`, 'info');
            updateUI();
        }
        
        function buyBus() {
            const routeId = parseInt(routeSelect.value);
            if (isNaN(routeId) || money < BUS_COST) return;
            const route = routes.find(r => r.id === routeId);
            if (!route) return;
            money -= BUS_COST;
            const startStop = route.stops[0];
            const busMarker = L.marker([startStop.lat, startStop.lng], { icon: busIcon, zIndexOffset: 1000 }).addTo(map);
            busMarker.bindPopup(`<b>Ônibus Rota ${route.id + 1}</b><br>Passageiros: 0/10`);
            const newBus = { type: 'bus', id: buses.length, routeId: route.id, marker: busMarker, currentStopIndex: 0, path: [], distanceTraveled: 0, passengers: [], capacity: 10 };
            buses.push(newBus);
            getRoutePath(route.stops[0], route.stops[1], pathData => { newBus.path = pathData; });
            logMessage(`Ônibus comprado para Rota ${route.id + 1}.`, "success");
            updateUI();
        }

        function buyTaxi() {
            if (money < TAXI_COST) return;
            money -= TAXI_COST;
            const startPos = buildings[Math.floor(Math.random() * buildings.length)];
            const taxiMarker = L.marker([startPos.lat, startPos.lng], { icon: taxiIcon, zIndexOffset: 1000 }).addTo(map);
            taxiMarker.bindPopup(`<b>Táxi ${taxis.length + 1}</b><br>Status: Ocioso`);
            taxis.push({ type: 'taxi', id: taxis.length, marker: taxiMarker, status: 'idle', passenger: null, path: [], distanceTraveled: 0 });
            logMessage("Táxi comprado e pronto para trabalhar!", "success");
            updateUI();
        }

        function spawnPassenger() {
            if (buildings.length < 2) return;
            const origin = buildings[Math.floor(Math.random() * buildings.length)];
            const destination = buildings[Math.floor(Math.random() * buildings.length)];
            if (origin === destination) return;
            const passenger = { id: Date.now(), origin, destination, status: 'waiting' };
            const nearestStartStopInfo = findNearestStop(passenger.origin);
            if (nearestStartStopInfo && nearestStartStopInfo.distance < 1000) {
                nearestStartStopInfo.stop.passengers.push(passenger);
            } else {
                passengers.push(passenger);
            }
        }

        function findNearestStop(position) {
            let closest = null, minDistance = Infinity;
            routes.forEach(route => {
                route.stops.forEach((stop) => {
                    const distance = L.latLng(position).distanceTo(L.latLng(stop));
                    if (distance < minDistance) {
                        minDistance = distance;
                        closest = { route, stop, distance };
                    }
                });
            });
            return closest;
        }
        
        function updatePassengersUI() {
            routes.forEach(route => {
                route.stops.forEach((stop, stopIndex) => {
                    const span = document.getElementById(`stop-${route.id}-${stopIndex}`);
                    if(span) span.textContent = stop.passengers.length;
                });
            });
        }

        function getRoutePath(start, end, callback) {
            // FIX: Use the correct factory function L.routing.osrmv1 (lowercase 'r')
            const router = L.routing.osrmv1({
                serviceUrl: 'https://router.project-osrm.org/route/v1',
                profile: 'driving',
            });

            router.route([L.latLng(start.lat, start.lng), L.latLng(end.lat, end.lng)], (err, routes) => {
                if (err || !routes || routes.length === 0) {
                    console.error("Erro de roteamento:", err);
                    // Provide an empty path to prevent crashes on routing failure
                    callback({ coordinates: [], instructions: [], summary: { totalDistance: 0, totalTime: 0 } });
                    return;
                }
                const route = routes[0];
                const pathData = {
                    coordinates: route.coordinates,
                    instructions: route.instructions,
                    summary: route.summary
                };
                callback(pathData);
            }, null, {
                steps: true,
                annotations: ['speed', 'duration', 'distance']
            });
        }

        function updateVehicles(vehicleList, deltaTime) {
            vehicleList.forEach(vehicle => {
                if (vehicle.type === 'taxi' && vehicle.status === 'idle') {
                    const waitingForTaxi = passengers.filter(p => p.status === 'waiting');
                    if (waitingForTaxi.length > 0) {
                        const passenger = waitingForTaxi.shift();
                        vehicle.status = 'pickup';
                        vehicle.passenger = passenger;
                        getRoutePath(vehicle.marker.getLatLng(), passenger.origin, pathData => {
                            vehicle.path = pathData; vehicle.distanceTraveled = 0;
                        });
                        vehicle.marker.setPopupContent(`<b>Táxi ${vehicle.id + 1}</b><br>A caminho`);
                    }
                    return;
                }

                if (!vehicle.path || !vehicle.path.coordinates || vehicle.path.coordinates.length === 0) return;

                const currentLeg = vehicle.path.instructions.find(instr => vehicle.distanceTraveled < instr.distance);
                const speedKmh = currentLeg ? (currentLeg.speed || 30) : 30; // km/h, com fallback para 30
                const speedMps = speedKmh / 3.6; // metros por segundo
                
                vehicle.distanceTraveled += speedMps * deltaTime;
                
                let traveled = 0;
                for (let i = 0; i < vehicle.path.coordinates.length - 1; i++) {
                    const start = vehicle.path.coordinates[i];
                    const end = vehicle.path.coordinates[i + 1];
                    const segmentDistance = start.distanceTo(end);
                    if (traveled + segmentDistance >= vehicle.distanceTraveled) {
                        const ratio = (vehicle.distanceTraveled - traveled) / segmentDistance;
                        const lat = start.lat + (end.lat - start.lat) * ratio;
                        const lng = start.lng + (end.lng - start.lng) * ratio;
                        vehicle.marker.setLatLng([lat, lng]);
                        break;
                    }
                    traveled += segmentDistance;
                }

                if (vehicle.distanceTraveled >= vehicle.path.summary.totalDistance) {
                    handleVehicleArrival(vehicle);
                }
            });
        }

        function handleVehicleArrival(vehicle) {
            if (vehicle.type === 'bus') {
                const route = routes.find(r => r.id === vehicle.routeId);
                if (!route) return;
                vehicle.currentStopIndex = (vehicle.currentStopIndex + 1) % route.stops.length;
                handleBusAtStop(vehicle);
                const nextStopIndex = (vehicle.currentStopIndex + 1) % route.stops.length;
                const currentStop = route.stops[vehicle.currentStopIndex];
                const nextStop = route.stops[nextStopIndex];
                getRoutePath(currentStop, nextStop, pathData => {
                    vehicle.path = pathData; vehicle.distanceTraveled = 0;
                });
            } else if (vehicle.type === 'taxi') {
                if (vehicle.status === 'pickup') {
                    vehicle.status = 'dropoff';
                    vehicle.marker.setLatLng(vehicle.passenger.origin);
                    getRoutePath(vehicle.passenger.origin, vehicle.passenger.destination, pathData => {
                        vehicle.path = pathData; vehicle.distanceTraveled = 0;
                    });
                    vehicle.marker.setPopupContent(`<b>Táxi ${vehicle.id + 1}</b><br>Levando ao destino`);
                } else if (vehicle.status === 'dropoff') {
                    const distance = vehicle.path.summary.totalDistance / 1000;
                    const fare = Math.max(5, distance * TAXI_FARE_PER_KM);
                    money += fare; passengersServed++;
                    logMessage(`Táxi deixou passageiro. +R$${fare.toFixed(2)}`, 'success');
                    
                    vehicle.status = 'idle'; vehicle.passenger = null; vehicle.path = [];
                    vehicle.marker.setPopupContent(`<b>Táxi ${vehicle.id + 1}</b><br>Status: Ocioso`);
                    updateUI();
                }
            }
        }

        function handleBusAtStop(bus) {
            const route = routes.find(r => r.id === bus.routeId);
            if (!route) return;
            const stop = route.stops[bus.currentStopIndex];
            
            const passengersToDrop = [];
            bus.passengers.forEach(p => {
                let bestStopForDest = null, minDistance = Infinity;
                route.stops.forEach(s => {
                    const d = L.latLng(p.destination).distanceTo(L.latLng(s));
                    if (d < minDistance) { minDistance = d; bestStopForDest = s; }
                });
                if (bestStopForDest === stop) passengersToDrop.push(p);
            });
            if (passengersToDrop.length > 0) {
                bus.passengers = bus.passengers.filter(p => !passengersToDrop.some(dp => dp.id === p.id));
                money += passengersToDrop.length * BUS_TICKET_PRICE;
                passengersServed += passengersToDrop.length;
                logMessage(`${passengersToDrop.length} passageiros desembarcaram. +R$${passengersToDrop.length * BUS_TICKET_PRICE}`, 'success');
            }

            const space = bus.capacity - bus.passengers.length;
            const boarded = stop.passengers.splice(0, space);
            if (boarded.length > 0) {
                bus.passengers.push(...boarded);
                logMessage(`${boarded.length} passageiros embarcaram.`, 'info');
            }
            
            bus.marker.setPopupContent(`<b>Ônibus Rota ${bus.id + 1}</b><br>Passageiros: ${bus.passengers.length}/${bus.capacity}`);
            updateUI();
        }

        init();
    </script>
</body>
</html>
